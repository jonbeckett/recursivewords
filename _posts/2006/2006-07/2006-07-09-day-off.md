---
title: Day Off
date: 2006-07-09
categories: [life]
tags: [life]
author: Jonathan Beckett
---

I woke up this morning at 10am and decided - on the basis of me never waking up that late - that it was time I had a day off.

I have been working on a big project at work since last monday, and am about to file in the region of 60 hours work for the week. Everything past 42 is guaranteed overtime, so I'm guessing the accounts department are going to have a shock.

W had a go at me on Thursday evening for working so many hours. While delivering a cup of tea to me at about 10pm she started...

W - "I bet you've not stopped all day have you"

JB - "nope"

W - "not even for lunch?"

JB - "nope"

W - "That's ridiculous - you should at least stop for lunch! It's not good for you!"

Oh my god... as I wrote that last line, I put a semi-colon on the end. Perhaps I have been working too much (for those who have no idea of the significance of that, I have been programming in a language over the last week where each line of programming is terminated by a semi-colon - ; - and I just used it in normal prose).

It does give something of an insight into the mind of a software developer though - that my mind has become so used to thinking in terms of programming recently that it's appearing in my writing. I'm trying to think of an analogy for those of you who have no experience of what I do.

Imagine you were a sculptor, but you can make anything appear out of thin air. Imagine you can make whatever you pull out of thin air do anything. Imagine then that if you make the smallest mistake in that thing, that the whole thing will not appear. That's software development. Within the confines of the computer, I can invent any abstract "thing" and invent what it does, how it works, and how it does it. I can invent the way you use it, and the way it appears. Sounds pretty cool, doesn't it - almost godly.

That's it - that's the analogy I'm looking for. Software development is like playing god. You start with a void, and into that void you create, invent, shape, nurture and train. Sometimes it takes thousands of lines of instructions to the computer to describe what you're creating - and sometimes it only takes a few. Sometimes the thousands of lines don't appear to do much - and sometimes a few lines can change everything - and yet if only one character is out of place it can be catastrophic (and usually is).

Sometimes you make mistakes in the logic behind your inventions. There is a somewhat famous story in computer science about one of the first chess programmes that was ever written. For months the developers worked on the program without realising that they had the main "evaluation" function backwards - the computer was playing to lose. Strangely, this taught them something too - that the best way to lose at a game is to play to win until a critical point.

The above example also taught a worrying lesson. At some point - probably in our lifetime - computers are going to be designed by computers. The danger is that a computer may well find insights in the design of themselves that humans could not. Through an accident, the chess program found a better way of losing a game than we could ever think up. What happens when a computer is designed using insights forged through brute-force invention (where the computer has tried a trillion times to design something in it's head until it hit upon something that worked).

The famous quote says that an infinite number of monkeys typing on an infinite number of typewriters could (given enough time) write the works of Shakespeare. What if quantum computing becomes a reality, and a computer tries an infinite number of times to better itself - and does so to such a level that we don't know how it works...